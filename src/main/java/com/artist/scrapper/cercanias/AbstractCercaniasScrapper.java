package com.artist.scrapper.cercanias;

import com.artist.Country;
import com.artist.scrapper.TSScrapperUtils;
import com.artist.scrapper.TransportScheduleScrapper;
import com.artist.vo.ArrivalData;
import com.artist.vo.Stop;
import org.jsoup.Connection;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;

import java.io.IOException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.List;

public abstract class AbstractCercaniasScrapper implements TransportScheduleScrapper
{
    //TODO fcres: Crear singleton

    abstract protected String getKernel();

    private static final String URL_PREFIX =
            "http://renfe.mobi/renfev2/resultado_cercanias.do" +
                    "?ga=false" +
                    "&ss=29AA445DE3845A2C5FE098B1A4F103E6" +
                    "&ho=00" +
                    "&horario=" +
                    "&horario=%20Ver%20horario";


    private static final String STOPS_URL_PREFIX =
            "http://horarios.renfe.com/cer/hjcer300.jsp" +
                    "?CP=NO" +
                    "&I=s" +
                    "&NUCLEO=";

    private static final Integer TOO_MUCH_SECONDS = 60 * 60; // One hour


    @Override
    public ScrapperType getScrapperType()
    {
        return ScrapperType.START_AND_END;
    }

    @Override
    public Country getCountryId()
    {
        return Country.SPAIN;
    }

    @Override
    public List<ArrivalData> retrieveBeginToEndETA(final String beginStopId, final String endStopId)
    {
        final String url = computeRequestUrl(beginStopId, endStopId);
        final Document doc = TSScrapperUtils.getJSoupHtmlDocument(url);

        final List<RowRawData> rawDataList = retrieveRawData(doc);
        return retrieveAAA(rawDataList);
    }



    private String computeRequestUrl(final String beginStopId, final String endStopId)
    {
        return URL_PREFIX +
                "&o=" + beginStopId +
                "&d=" + endStopId +
                "&nucleo=" + getKernel() +
                "&ciudad=";// + getCity();
    }

    @Override
    public List<ArrivalData> retrieveBeginAndLinesETA(final String stopId, final List<String> lineName)
    {
        //TODO fcres: Review this code

        return Collections.EMPTY_LIST;
    }

    @Override
    public List<Stop> retrieveAllStops()
    {
        List<Stop> result = new ArrayList<Stop>();

        Connection dom;

        try
        {
            dom = Jsoup.connect(STOPS_URL_PREFIX + getKernel());
            final Document doc = dom.get();

            final List<RowRawData> rowRawDatas = retrieveRawData(doc);
            result = parseStops(doc);
        }
        catch (IOException ioe)
        {
            System.err.println(ioe.getMessage());
        }

        return result;
    }

    @Override
    public List<String> retrieveStopLines(final String stopId)
    {
        return Collections.EMPTY_LIST;  //TODO FCRES: Autogenerated, modify
    }



    protected List<RowRawData> retrieveRawData (final Document doc)
    {
        final List<RowRawData> result = new ArrayList<RowRawData>();

        final Elements rows = doc.select("div.linea");

        boolean isHeader = true;

        for (final Element row : rows)
        {
            if (isHeader)
            {
                isHeader = false;
            }
            else
            {
                final Elements columns = row.select("div");
                final RowRawData arrivalData = new RowRawData(getColumnCleanValue(columns, 1),
                                                               getColumnCleanValue(columns, 2));
                result.add(arrivalData);
            }

        }

        return result;
    }





    protected List<ArrivalData> retrieveAAA (final List<RowRawData> rawDataList)
    {

        final List<ArrivalData> result = new ArrayList<ArrivalData>();

        for (final RowRawData rawData : rawDataList)
        {
            final Integer secondsLeft = computeSecondsLeft(rawData.time);
            final boolean isTooMuchTime = ((secondsLeft != null) && (secondsLeft > TOO_MUCH_SECONDS));

            final ArrivalData arrivalData = new ArrivalData(rawData.line,
                                                            "stop",
                                                            "dest",
                                                            secondsLeft,
                                                            (secondsLeft == null),
                                                            isTooMuchTime);
            result.add(arrivalData);

        }

        return result;
    }




    static protected List<Stop> parseStops (final Document doc)
    {
        final List<Stop> result = new ArrayList<Stop>();
        boolean isHeader = true;

        final Elements options = doc.select("select.caja_texto1 option");

        for (final Element option : options)
        {
            if (isHeader)
            {
                isHeader = false;
            }
            else
            {
                result.add(
                        new Stop(option.attr("value"),
                                 option.text()));
            }
        }

        return result;
    }


    private String getColumnCleanValue(final Elements columns, final int position)
    {
        final String text = columns.get(position).text();
        return text.substring(1);
    }

    private static Integer computeSecondsLeft(final String time)
    {

        Integer result = null;

        final SimpleDateFormat dateOnlyDateFormat = new SimpleDateFormat("dd/MM/yyyy ");
        final SimpleDateFormat completeDateFormat = new SimpleDateFormat("dd/MM/yyyy HH.mm");

        final Date now = new Date();

        StringBuilder currentDateString = new StringBuilder(dateOnlyDateFormat.format(now));
        currentDateString.append(time);

        try
        {
            final Date targetDate = completeDateFormat.parse(currentDateString.toString());
            result = TSScrapperUtils.getDifferenceInSeconds(now, targetDate);
        }
        catch (ParseException e)
        {

            //TODO fcres: ver que hacer con las excepciones



            e.printStackTrace();  //TODO FCRES: Autogenerated, modify
        }

        return result;
    }

    private class RowRawData
    {
        private String line;
        private String time;

        private RowRawData(String line, String time)
        {
            this.line = line;
            this.time = time;
        }
    }


}
