package com.artist.scrapper;

import com.artist.Country;
import com.artist.vo.ArrivalData;
import com.artist.vo.Stop;
import org.jsoup.Connection;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;

import java.io.IOException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

public enum CercaniasScrapper implements TransportScheduleScrapper
{
    // Singleton instance
    INSTANCE;


    private static final String URL_PREFIX =
            "http://renfe.mobi/renfev2/resultado_cercanias.do" +
                    "?ga=false" +
                    "&nucleo=10" +
                    "&ciudad=madrid" +
                    "&ss=29AA445DE3845A2C5FE098B1A4F103E6" +
                    "&d=35600" +
                    "&ho=00" +
                    "&horario=" +
                    "&horario=%20Ver%20horario" +
                    "&o=18000";

    private static final String STOPS_URL_PREFIX =
            "http://horarios.renfe.com/cer/hjcer300.jsp" +
                    "?CP=NO" +
                    "&I=s" +
                    "&NUCLEO=10";

    private static final Integer TOO_MUCH_SECONDS = 60 * 60; // One hour


    @Override
    public Country getCountryId()
    {
        return Country.SPAIN;
    }

    @Override
    public Integer getCompanyId()
    {
        return null;  //TODO FCRES: Autogenerated, modify
    }

    @Override
    public List<Integer> retrieveLineETA(String lineName, String stopId)
    {
        //TODO fcres: Review this code
        final List<Integer> result = new ArrayList<Integer>();

        return result;
    }

    @Override
    public List<Integer> retrieveStopETAList(String stopId)
    {
        //TODO fcres: Review this code
        final List<Integer> result = new ArrayList<Integer>();

     /*   final List<ArrivalData> arrivalDatas = retrieveArrivalDataList();

        for (final ArrivalData arrivalData : arrivalDatas)
        {
                result.add(Integer.valueOf(arrivalData.getSecondsLeft()));
        }
                        */
        return result;
    }

    @Override
    public List<Stop> retrieveAllStops()
    {
        List<Stop> result = new ArrayList<Stop>();

        Connection dom;

        try
        {
            dom = Jsoup.connect(STOPS_URL_PREFIX);
            final Document doc = dom.get();

            result = parseStops(doc);
        }
        catch (IOException ioe)
        {
            System.err.println(ioe.getMessage());
        }

        return result;
    }

    public List<ArrivalData> retrieveArrivalDataList()
    {
        List<ArrivalData> result = new ArrayList<ArrivalData>();

        Connection dom;

        try
        {
            dom = Jsoup.connect(URL_PREFIX);
            final Document doc = dom.get();

            result = parse(doc);
        }
        catch (IOException ioe)
        {
            System.err.println(ioe.getMessage());
        }

        return result;
    }



    protected List<ArrivalData> retrieveRawData()
    {



        return null;
    }



    protected List<ArrivalData> parse (final Document doc)
    {
        final List<ArrivalData> result = new ArrayList<ArrivalData>();

        final Elements rows = doc.select("div.linea");

        boolean isHeader = true;

        for (final Element row : rows)
        {
            if (isHeader)
            {
                isHeader = false;
            }
            else
            {
                final Elements columns = row.select("div");
                final Integer secondsLeft = computeSecondsLeft(getColumnCleanValue(columns, 2));
                final boolean isTooMuchTime = ((secondsLeft != null) && (secondsLeft > TOO_MUCH_SECONDS));

                final ArrivalData arrivalData = new ArrivalData(getColumnCleanValue(columns, 1),
                                                                "stop",
                                                                "dest",
                                                                secondsLeft,
                                                                (secondsLeft == null),
                                                                isTooMuchTime);

                result.add(arrivalData);
            }

        }

        return result;
    }



    protected List<Stop> parseStops (final Document doc)
    {
        final List<Stop> result = new ArrayList<Stop>();
        boolean isHeader = true;

        final Elements options = doc.select("select.caja_texto1 option");

        for (final Element option : options)
        {
            if (isHeader)
            {
                isHeader = false;
            }
            else
            {
                result.add(
                        new Stop(option.attr("value"),
                                 option.text()));
            }
        }

        return result;
    }




    private String getColumnCleanValue(final Elements columns, final int position)
    {
        final String text = columns.get(position).text();
        return text.substring(1);
    }

    private static Integer computeSecondsLeft(final String time)
    {

        Integer result = null;

        final SimpleDateFormat dateOnlyDateFormat = new SimpleDateFormat("dd/MM/yyyy ");
        final SimpleDateFormat completeDateFormat = new SimpleDateFormat("dd/MM/yyyy HH.mm");

        final Date now = new Date();

        StringBuilder currentDateString = new StringBuilder(dateOnlyDateFormat.format(now));
        currentDateString.append(time);

        try
        {
            final Date targetDate = completeDateFormat.parse(currentDateString.toString());
            result = getDifferenceInSeconds(now, targetDate);
        }
        catch (ParseException e)
        {

            //TODO fcres: ver que hacer con las excepciones



            e.printStackTrace();  //TODO FCRES: Autogenerated, modify
        }

        return result;
    }


    private static Integer getDifferenceInSeconds(final Date firstDate, final Date secondDate)
    {
        Integer result = null;

        final Long secondsLeft = (secondDate.getTime() - firstDate.getTime()) / 1000;

        if ((secondsLeft > 0) &&
                (secondsLeft < Integer.MAX_VALUE))
        {
            result = secondsLeft.intValue();
        }

        return result;
    }


}
